# Database Schema Documentation

## Table of Contents

1. [Overview](#overview)
2. [Database Extensions](#database-extensions)
3. [Dimension Tables](#dimension-tables)
4. [Core Entity Tables](#core-entity-tables)
5. [Document Management Tables](#document-management-tables)
6. [RAG & Search Tables](#rag--search-tables)
7. [Relationships & Foreign Keys](#relationships--foreign-keys)
8. [Indexes](#indexes)
9. [Triggers & Functions](#triggers--functions)
10. [Data Types & Constraints](#data-types--constraints)
11. [Sample Queries](#sample-queries)

---

## Overview

**Database Name**: `cases_llama3.3`  
**PostgreSQL Version**: 16+  
**Primary Purpose**: Legal case storage, AI-extracted entity management, and RAG (Retrieval-Augmented Generation) capabilities

### Key Features

- **Vector Search**: pgvector extension for 1024-dimensional embeddings
- **Full-Text Search**: Built-in PostgreSQL tsvector with GIN indexes
- **Fuzzy Matching**: pg_trgm for trigram similarity
- **Case-Insensitive Text**: citext for normalized string comparisons
- **Referential Integrity**: Comprehensive foreign key constraints
- **Automatic Timestamps**: Triggers for `updated_at` columns

### Database Statistics

- **Total Tables**: 30+
- **Dimension Tables**: 5
- **Core Entity Tables**: 8
- **RAG Tables**: 8
- **Total Columns**: 200+
- **Vector Dimensions**: 1024 (float32)

---

## Database Extensions

### Required Extensions

```sql
CREATE EXTENSION IF NOT EXISTS citext;      -- Case-insensitive text
CREATE EXTENSION IF NOT EXISTS vector;      -- Vector similarity search
CREATE EXTENSION IF NOT EXISTS pg_trgm;     -- Trigram matching
CREATE EXTENSION IF NOT EXISTS unaccent;    -- Accent removal
CREATE EXTENSION IF NOT EXISTS pgcrypto;    -- UUID generation
```

### Extension Usage

| Extension    | Purpose                       | Usage Example               |
| ------------ | ----------------------------- | --------------------------- |
| **citext**   | Case-insensitive text columns | `court CITEXT`              |
| **vector**   | Embedding storage & search    | `embedding VECTOR(1024)`    |
| **pg_trgm**  | Fuzzy text matching           | `similarity(text1, text2)`  |
| **unaccent** | Accent-insensitive search     | `unaccent('café') = 'cafe'` |
| **pgcrypto** | UUID generation               | `gen_random_uuid()`         |

---

## Dimension Tables

Dimension tables are lookup/reference tables used for data normalization and categorization.

### 1. case_types

**Purpose**: Categorize cases by legal type

```sql
CREATE TABLE IF NOT EXISTS case_types (
    case_type_id BIGINT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    case_type CITEXT UNIQUE NOT NULL,
    description TEXT,
    jurisdiction CITEXT,
    created_at TIMESTAMP NOT NULL DEFAULT NOW()
);
```

**Columns**:
| Column | Type | Constraints | Description |
|--------|------|-------------|-------------|
| case_type_id | BIGINT | PK, IDENTITY | Auto-generated unique ID |
| case_type | CITEXT | UNIQUE, NOT NULL | Case type name (e.g., "divorce", "custody") |
| description | TEXT | NULL | Detailed description |
| jurisdiction | CITEXT | NULL | Jurisdiction (e.g., "WA", "Federal") |
| created_at | TIMESTAMP | NOT NULL, DEFAULT NOW() | Creation timestamp |

**Example Data**:

```sql
INSERT INTO case_types (case_type, description, jurisdiction) VALUES
('divorce', 'Divorce proceedings', 'WA'),
('custody', 'Child custody disputes', 'WA'),
('support', 'Child/spousal support', 'WA'),
('property', 'Property division', 'WA');
```

---

### 2. stage_types

**Purpose**: Define legal proceeding stages

```sql
CREATE TABLE IF NOT EXISTS stage_types (
    stage_type_id BIGINT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    stage_type CITEXT UNIQUE NOT NULL,
    description TEXT,
    level INTEGER NOT NULL,
    created_at TIMESTAMP NOT NULL DEFAULT NOW()
);
```

**Columns**:
| Column | Type | Constraints | Description |
|--------|------|-------------|-------------|
| stage_type_id | BIGINT | PK, IDENTITY | Auto-generated unique ID |
| stage_type | CITEXT | UNIQUE, NOT NULL | Stage name (e.g., "trial", "appeal") |
| description | TEXT | NULL | Stage description |
| level | INTEGER | NOT NULL | Hierarchical level (1=trial, 2=appeal) |
| created_at | TIMESTAMP | NOT NULL, DEFAULT NOW() | Creation timestamp |

**Example Data**:

```sql
INSERT INTO stage_types (stage_type, description, level) VALUES
('trial', 'Trial court proceedings', 1),
('appeal', 'Court of Appeals', 2),
('supreme', 'Supreme Court', 3);
```

---

### 3. document_types

**Purpose**: Categorize legal documents

```sql
CREATE TABLE IF NOT EXISTS document_types (
    document_type_id BIGINT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    document_type CITEXT UNIQUE NOT NULL,
    description TEXT,
    has_decision BOOLEAN DEFAULT FALSE,
    created_at TIMESTAMP NOT NULL DEFAULT NOW()
);
```

**Columns**:
| Column | Type | Constraints | Description |
|--------|------|-------------|-------------|
| document_type_id | BIGINT | PK, IDENTITY | Auto-generated unique ID |
| document_type | CITEXT | UNIQUE, NOT NULL | Document type (e.g., "opinion", "order") |
| description | TEXT | NULL | Document description |
| has_decision | BOOLEAN | DEFAULT FALSE | Whether document contains decision |
| created_at | TIMESTAMP | NOT NULL, DEFAULT NOW() | Creation timestamp |

**Example Data**:

```sql
INSERT INTO document_types (document_type, description, has_decision) VALUES
('opinion', 'Court opinion/decision', true),
('order', 'Court order', true),
('motion', 'Legal motion', false),
('brief', 'Legal brief/argument', false);
```

---

### 4. courts_dim

**Purpose**: Normalize court information

```sql
CREATE TABLE IF NOT EXISTS courts_dim (
    court_id BIGINT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    court CITEXT UNIQUE NOT NULL,
    level CITEXT,
    jurisdiction CITEXT,
    district CITEXT,
    county CITEXT
);
```

**Columns**:
| Column | Type | Constraints | Description |
|--------|------|-------------|-------------|
| court_id | BIGINT | PK, IDENTITY | Auto-generated unique ID |
| court | CITEXT | UNIQUE, NOT NULL | Full court name |
| level | CITEXT | NULL | Court level (e.g., "Appeals", "Supreme") |
| jurisdiction | CITEXT | NULL | Jurisdiction (e.g., "WA", "Federal") |
| district | CITEXT | NULL | District/division |
| county | CITEXT | NULL | County |

**Example Data**:

```sql
INSERT INTO courts_dim (court, level, jurisdiction, district) VALUES
('Washington State Court of Appeals Division One', 'Appeals', 'WA', 'Division I'),
('Washington State Court of Appeals Division Two', 'Appeals', 'WA', 'Division II'),
('Washington State Supreme Court', 'Supreme', 'WA', NULL);
```

---

### 5. statutes_dim

**Purpose**: Store legal statute references

```sql
CREATE TABLE IF NOT EXISTS statutes_dim (
    statute_id BIGINT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    jurisdiction CITEXT,
    code CITEXT,
    title CITEXT,
    section CITEXT,
    subsection CITEXT,
    display_text CITEXT
);

CREATE UNIQUE INDEX IF NOT EXISTS uq_statute_parts
ON statutes_dim (jurisdiction, code, title, section, COALESCE(subsection,''));
```

**Columns**:
| Column | Type | Constraints | Description |
|--------|------|-------------|-------------|
| statute_id | BIGINT | PK, IDENTITY | Auto-generated unique ID |
| jurisdiction | CITEXT | NULL | Jurisdiction (e.g., "WA", "US") |
| code | CITEXT | NULL | Legal code (e.g., "RCW", "USC") |
| title | CITEXT | NULL | Title number (e.g., "26") |
| section | CITEXT | NULL | Section number (e.g., "09.090") |
| subsection | CITEXT | NULL | Subsection (e.g., "(a)(1)") |
| display_text | CITEXT | NULL | Full display text |

**Example Data**:

```sql
INSERT INTO statutes_dim (jurisdiction, code, title, section, subsection, display_text) VALUES
('WA', 'RCW', '26', '09.090', NULL, 'RCW 26.09.090'),
('WA', 'RCW', '26', '19.071', NULL, 'RCW 26.19.071'),
('US', 'USC', '10', '1408', '(a)(4)(A)(iii)', '10 U.S.C. § 1408(a)(4)(A)(iii)');
```

---

## Core Entity Tables

Core entity tables store the primary legal case data and related entities.

### 1. cases

**Purpose**: Main case information (central entity)

```sql
CREATE TABLE IF NOT EXISTS cases (
    case_id           BIGINT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    case_file_id      CITEXT,
    title             CITEXT NOT NULL,
    court_level       CITEXT,
    court             CITEXT,
    district          CITEXT,
    county            CITEXT,
    docket_number     CITEXT,
    source_docket_number CITEXT,
    trial_judge       CITEXT,

    -- Trial court dates
    trial_start_date     DATE,
    trial_end_date       DATE,
    trial_published_date DATE,

    -- Appellate court dates
    appeal_start_date    DATE,
    appeal_end_date      DATE,
    appeal_published_date DATE,

    -- Additional dates
    oral_argument_date   DATE,
    published         BOOLEAN,

    -- Content
    summary           TEXT,
    full_text         TEXT,
    full_embedding    VECTOR(1024),

    -- Outcomes
    overall_case_outcome CITEXT,

    -- Foreign Keys
    case_type_id        BIGINT REFERENCES case_types(case_type_id) ON DELETE SET NULL,
    stage_type_id       BIGINT REFERENCES stage_types(stage_type_id) ON DELETE SET NULL,
    court_id            BIGINT REFERENCES courts_dim(court_id) ON DELETE SET NULL,
    parent_case_id      BIGINT REFERENCES cases(case_id) ON DELETE SET NULL,

    -- Legacy fields
    case_type           CITEXT DEFAULT 'divorce',
    winner_legal_role   CITEXT,
    winner_personal_role CITEXT,
    appeal_outcome       CITEXT,

    -- Source tracking
    source_file         CITEXT,
    source_file_path    TEXT,
    source_url          TEXT DEFAULT NULL,
    extraction_timestamp TIMESTAMP,

    -- Metadata
    created_at TIMESTAMP NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMP NOT NULL DEFAULT NOW()
);

CREATE TRIGGER trg_cases_updated BEFORE UPDATE ON cases
FOR EACH ROW EXECUTE FUNCTION set_updated_at();
```

**Key Columns**:

| Column                | Type         | Description          | Example                            |
| --------------------- | ------------ | -------------------- | ---------------------------------- |
| case_id               | BIGINT       | Primary key          | 12345                              |
| case_file_id          | CITEXT       | Court file number    | "73404-1"                          |
| title                 | CITEXT       | Case name            | "In Re Marriage of Smith v. Jones" |
| court_level           | CITEXT       | Court level          | "Appeals", "Supreme"               |
| docket_number         | CITEXT       | Appeals docket       | "50059-1-II"                       |
| trial_start_date      | DATE         | Trial start          | '2020-01-15'                       |
| appeal_published_date | DATE         | Appeal decision date | '2021-06-20'                       |
| published             | BOOLEAN      | Published status     | true                               |
| summary               | TEXT         | Case summary         | "This case involves..."            |
| full_embedding        | VECTOR(1024) | Semantic embedding   | [0.123, -0.456, ...]               |
| overall_case_outcome  | CITEXT       | Final outcome        | "affirmed", "reversed"             |
| winner_legal_role     | CITEXT       | Winning party        | "Appellant", "Respondent"          |

**Indexes**:

```sql
CREATE INDEX idx_cases_case_type_id ON cases(case_type_id);
CREATE INDEX idx_cases_court_id ON cases(court_id);
CREATE INDEX idx_cases_embedding ON cases USING ivfflat (full_embedding vector_cosine_ops);
CREATE INDEX idx_cases_title_gin ON cases USING gin(to_tsvector('english', title));
CREATE INDEX idx_cases_summary_gin ON cases USING gin(to_tsvector('english', summary));
```

---

### 2. parties

**Purpose**: Case parties (plaintiffs, defendants, appellants, respondents)

```sql
CREATE TABLE IF NOT EXISTS parties (
    party_id         BIGINT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    case_id          BIGINT NOT NULL REFERENCES cases(case_id) ON DELETE CASCADE,
    name             CITEXT NOT NULL,
    legal_role       CITEXT,
    personal_role    CITEXT,
    party_type       CITEXT,
    created_at       TIMESTAMP NOT NULL DEFAULT NOW()
);

CREATE INDEX IF NOT EXISTS idx_parties_case_id ON parties(case_id);
CREATE INDEX IF NOT EXISTS idx_parties_name ON parties(name);
```

**Columns**:
| Column | Type | Description | Example Values |
|--------|------|-------------|----------------|
| party_id | BIGINT | Primary key | 1, 2, 3... |
| case_id | BIGINT | Foreign key to cases | 12345 |
| name | CITEXT | Party full name | "John Smith", "Jane Doe" |
| legal_role | CITEXT | Legal role | "Appellant", "Respondent", "Petitioner" |
| personal_role | CITEXT | Personal role | "Husband", "Wife", "Parent" |
| party_type | CITEXT | Entity type | "Individual", "Organization" |

**Legal Roles**:

- Appellant
- Respondent
- Petitioner
- Third Party
- Appellant/Cross Respondent
- Respondent/Cross Appellant

**Personal Roles** (Family Law):

- Husband
- Wife
- Parent
- Estate
- Other

---

### 3. attorneys

**Purpose**: Legal representation information

```sql
CREATE TABLE IF NOT EXISTS attorneys (
    attorney_id      BIGINT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    case_id          BIGINT NOT NULL REFERENCES cases(case_id) ON DELETE CASCADE,
    name             CITEXT NOT NULL,
    firm_name        CITEXT,
    firm_address     TEXT,
    representing     CITEXT,
    attorney_type    CITEXT,
    created_at       TIMESTAMP NOT NULL DEFAULT NOW()
);

CREATE INDEX IF NOT EXISTS idx_attorneys_case_id ON attorneys(case_id);
CREATE INDEX IF NOT EXISTS idx_attorneys_name ON attorneys(name);
```

**Columns**:
| Column | Type | Description | Example Values |
|--------|------|-------------|----------------|
| attorney_id | BIGINT | Primary key | 1, 2, 3... |
| case_id | BIGINT | Foreign key to cases | 12345 |
| name | CITEXT | Attorney name | "Sarah Johnson" |
| firm_name | CITEXT | Law firm | "Johnson & Associates" |
| firm_address | TEXT | Full address | "123 Main St, Seattle, WA" |
| representing | CITEXT | Who they represent | "Appellant", "Respondent" |
| attorney_type | CITEXT | Attorney type | "Attorney", "Counsel", "Public Defender" |

---

### 4. judges

**Purpose**: Judges involved in case (trial and appellate)

```sql
CREATE TABLE IF NOT EXISTS judges (
    judge_id         BIGINT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    case_id          BIGINT NOT NULL REFERENCES cases(case_id) ON DELETE CASCADE,
    judge_name       CITEXT NOT NULL,
    role             CITEXT,
    created_at       TIMESTAMP NOT NULL DEFAULT NOW()
);

CREATE INDEX IF NOT EXISTS idx_judges_case_id ON judges(case_id);
CREATE INDEX IF NOT EXISTS idx_judges_name ON judges(judge_name);
```

**Columns**:
| Column | Type | Description | Example Values |
|--------|------|-------------|----------------|
| judge_id | BIGINT | Primary key | 1, 2, 3... |
| case_id | BIGINT | Foreign key to cases | 12345 |
| judge_name | CITEXT | Judge name | "Honorable Mary Smith" |
| role | CITEXT | Judge role | "Authored by", "Concurring", "Dissenting", "Joining" |

**Judge Roles**:

- **Authored by**: Judge who wrote the opinion
- **Concurring**: Judge who agrees with decision
- **Dissenting**: Judge who disagrees
- **Joining**: Judge who joins another's opinion

---

### 5. issues_decisions

**Purpose**: Legal issues and their decisions (Washington State divorce appeals categorization)

```sql
CREATE TABLE IF NOT EXISTS issues_decisions (
    issue_id           BIGINT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    case_id            BIGINT NOT NULL REFERENCES cases(case_id) ON DELETE CASCADE,

    -- Washington State divorce appeals hierarchy
    category           CITEXT NOT NULL,
    subcategory        CITEXT NOT NULL,
    rcw_reference      CITEXT,
    keywords           CITEXT[],

    -- Issue details
    issue_summary      TEXT NOT NULL,

    -- Decision details
    decision_stage     CITEXT,
    decision_summary   TEXT,
    appeal_outcome     CITEXT,
    winner_legal_role  CITEXT,
    winner_personal_role CITEXT,

    -- AI metadata
    confidence_score   REAL,

    created_at TIMESTAMP NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMP NOT NULL DEFAULT NOW()
);

CREATE TRIGGER trg_issues_decisions_updated BEFORE UPDATE ON issues_decisions
FOR EACH ROW EXECUTE FUNCTION set_updated_at();

CREATE INDEX IF NOT EXISTS idx_issues_decisions_case_id ON issues_decisions(case_id);
CREATE INDEX IF NOT EXISTS idx_issues_decisions_category ON issues_decisions(category);
```

**Washington State Issue Categories**:

| Category                      | Example Subcategories                                 | RCW References |
| ----------------------------- | ----------------------------------------------------- | -------------- |
| Spousal Support / Maintenance | Duration, Amount calculation, Imputed income          | RCW 26.09.090  |
| Child Support                 | Income determination, Deviations, Retroactive support | RCW 26.19.071  |
| Parenting Plan / Custody      | Residential schedule, Decision-making, Relocation     | RCW 26.09.187  |
| Property Division / Debt      | Valuation, Characterization, Division fairness        | RCW 26.09.080  |
| Attorney Fees & Costs         | Fee awards, Sanctions                                 | RCW 26.09.140  |
| Procedural & Evidentiary      | Abuse of discretion, Evidentiary rulings              | Various        |
| Jurisdiction & Venue          | Subject matter, Personal jurisdiction                 | RCW 26.09.010  |
| Enforcement & Contempt        | Willfulness, Sanctions                                | RCW 26.09.160  |
| Modification Orders           | Substantial change, Retroactive application           | RCW 26.09.170  |
| Miscellaneous                 | Other rare issues                                     | Various        |

**Appeal Outcomes**:

- affirmed
- reversed
- remanded
- dismissed
- partial
- split

---

### 6. arguments

**Purpose**: Arguments presented by parties and court reasoning

```sql
CREATE TABLE IF NOT EXISTS arguments (
    argument_id        BIGINT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    case_id            BIGINT NOT NULL REFERENCES cases(case_id) ON DELETE CASCADE,
    issue_id           BIGINT NOT NULL REFERENCES issues_decisions(issue_id) ON DELETE CASCADE,

    side               CITEXT NOT NULL,
    argument_text      TEXT NOT NULL,

    created_at TIMESTAMP NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMP NOT NULL DEFAULT NOW()
);

CREATE TRIGGER trg_arguments_updated BEFORE UPDATE ON arguments
FOR EACH ROW EXECUTE FUNCTION set_updated_at();

CREATE INDEX IF NOT EXISTS idx_arguments_case_id ON arguments(case_id);
CREATE INDEX IF NOT EXISTS idx_arguments_issue_id ON arguments(issue_id);
```

**Columns**:
| Column | Type | Description | Values |
|--------|------|-------------|--------|
| argument_id | BIGINT | Primary key | 1, 2, 3... |
| case_id | BIGINT | Foreign key to cases | 12345 |
| issue_id | BIGINT | Foreign key to issues | 456 |
| side | CITEXT | Who's arguing | "Appellant", "Respondent", "Court" |
| argument_text | TEXT | Argument content | "The trial court erred by..." |

---

### 7. citations (citation_edges)

**Purpose**: Legal citation relationships (precedent tracking)

```sql
CREATE TABLE IF NOT EXISTS citation_edges (
    citation_id        BIGINT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    citing_case_id     BIGINT NOT NULL REFERENCES cases(case_id) ON DELETE CASCADE,
    cited_case_id      BIGINT REFERENCES cases(case_id) ON DELETE SET NULL,
    citation           CITEXT NOT NULL,
    citation_context   TEXT,
    relevance          TEXT,
    created_at         TIMESTAMP NOT NULL DEFAULT NOW()
);

CREATE INDEX IF NOT EXISTS idx_citations_citing ON citation_edges(citing_case_id);
CREATE INDEX IF NOT EXISTS idx_citations_cited ON citation_edges(cited_case_id);
```

**Columns**:
| Column | Type | Description | Example |
|--------|------|-------------|---------|
| citation_id | BIGINT | Primary key | 1, 2, 3... |
| citing_case_id | BIGINT | Current case | 12345 |
| cited_case_id | BIGINT | Referenced case (if in DB) | 789 |
| citation | CITEXT | Citation text | "123 Wn.2d 456" |
| citation_context | TEXT | Where cited | "In Smith v. Jones..." |
| relevance | TEXT | Why cited | "For standard of review" |

---

## Document Management Tables

### 1. documents

**Purpose**: Track document lifecycle and metadata

```sql
CREATE TABLE IF NOT EXISTS documents (
    document_id          BIGINT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    case_id              BIGINT NOT NULL REFERENCES cases(case_id) ON DELETE CASCADE,
    stage_type_id        BIGINT NOT NULL REFERENCES stage_types(stage_type_id) ON DELETE RESTRICT,
    document_type_id     BIGINT NOT NULL REFERENCES document_types(document_type_id) ON DELETE RESTRICT,
    title                TEXT,
    source_url           TEXT,
    local_path           TEXT,
    file_size            BIGINT,
    page_count           INTEGER,
    processing_status    CITEXT DEFAULT 'pending',
    created_at           TIMESTAMP NOT NULL DEFAULT NOW(),
    updated_at           TIMESTAMP NOT NULL DEFAULT NOW()
);

CREATE TRIGGER trg_documents_updated BEFORE UPDATE ON documents
FOR EACH ROW EXECUTE FUNCTION set_updated_at();

CREATE INDEX IF NOT EXISTS idx_documents_case_id ON documents(case_id);
CREATE INDEX IF NOT EXISTS idx_documents_status ON documents(processing_status);
```

**Processing Statuses**:

- pending
- processing
- completed
- failed
- indexed

**Columns**:
| Column | Type | Description |
|--------|------|-------------|
| document_id | BIGINT | Primary key |
| case_id | BIGINT | Related case |
| stage_type_id | BIGINT | Legal stage |
| document_type_id | BIGINT | Document type |
| title | TEXT | Document title |
| source_url | TEXT | Original URL |
| local_path | TEXT | File system path |
| file_size | BIGINT | File size in bytes |
| page_count | INTEGER | Number of pages |
| processing_status | CITEXT | Current status |

---

## RAG & Search Tables

These tables enable advanced search capabilities: semantic (vector), lexical (word), and phrase-based.

### 1. case_chunks

**Purpose**: Text chunks with embeddings for RAG

```sql
CREATE TABLE IF NOT EXISTS case_chunks (
    chunk_id       UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    case_id        BIGINT NOT NULL REFERENCES cases(case_id) ON DELETE CASCADE,
    chunk_order    INTEGER NOT NULL,
    text           TEXT NOT NULL,
    section        CITEXT,
    word_count     INTEGER,
    char_count     INTEGER,
    embedding      VECTOR(1024),
    created_at     TIMESTAMP NOT NULL DEFAULT NOW()
);

CREATE INDEX IF NOT EXISTS idx_case_chunks_case_id ON case_chunks(case_id);
CREATE INDEX IF NOT EXISTS idx_case_chunks_order ON case_chunks(case_id, chunk_order);
CREATE INDEX IF NOT EXISTS idx_case_chunks_embedding ON case_chunks
    USING ivfflat (embedding vector_cosine_ops) WITH (lists = 100);
```

**Columns**:
| Column | Type | Description |
|--------|------|-------------|
| chunk_id | UUID | Primary key (UUID) |
| case_id | BIGINT | Foreign key to cases |
| chunk_order | INTEGER | Sequence number |
| text | TEXT | Chunk content |
| section | CITEXT | Legal section (e.g., "FACTS", "ANALYSIS") |
| word_count | INTEGER | Word count |
| char_count | INTEGER | Character count |
| embedding | VECTOR(1024) | Semantic embedding |

**Legal Sections**:

- HEADER
- PARTIES
- PROCEDURAL
- FACTS
- ANALYSIS
- HOLDING
- CONTENT (default)

---

### 2. word_dictionary

**Purpose**: Unique word storage with IDs

```sql
CREATE TABLE IF NOT EXISTS word_dictionary (
    word_id        BIGINT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    word           CITEXT UNIQUE NOT NULL,
    frequency      INTEGER DEFAULT 1,
    created_at     TIMESTAMP NOT NULL DEFAULT NOW()
);

CREATE INDEX IF NOT EXISTS idx_word_dictionary_word ON word_dictionary(word);
```

**Columns**:
| Column | Type | Description |
|--------|------|-------------|
| word_id | BIGINT | Primary key |
| word | CITEXT | Normalized word (lowercase) |
| frequency | INTEGER | Total occurrences across corpus |
| created_at | TIMESTAMP | First seen |

**Usage**: Enable exact word searches and position tracking

---

### 3. word_occurrence

**Purpose**: Track every word position in every chunk

```sql
CREATE TABLE IF NOT EXISTS word_occurrence (
    case_id        BIGINT NOT NULL REFERENCES cases(case_id) ON DELETE CASCADE,
    chunk_id       UUID NOT NULL REFERENCES case_chunks(chunk_id) ON DELETE CASCADE,
    word_id        BIGINT NOT NULL REFERENCES word_dictionary(word_id) ON DELETE CASCADE,
    position       INTEGER NOT NULL,
    PRIMARY KEY (chunk_id, word_id, position)
);

CREATE INDEX IF NOT EXISTS idx_word_occurrence_word_id ON word_occurrence(word_id);
CREATE INDEX IF NOT EXISTS idx_word_occurrence_case_id ON word_occurrence(case_id);
CREATE INDEX IF NOT EXISTS idx_word_occurrence_chunk_id ON word_occurrence(chunk_id);
```

**Columns**:
| Column | Type | Description |
|--------|------|-------------|
| case_id | BIGINT | Case reference |
| chunk_id | UUID | Chunk reference |
| word_id | BIGINT | Word reference |
| position | INTEGER | Position in chunk (0-indexed) |

**Composite Primary Key**: `(chunk_id, word_id, position)` ensures unique positions

**Use Cases**:

- Exact phrase matching ("child custody" = positions 10, 11)
- Proximity searches (words within N distance)
- Context window retrieval

---

### 4. case_phrases

**Purpose**: Legal n-gram phrases with frequencies

```sql
CREATE TABLE IF NOT EXISTS case_phrases (
    phrase_id      BIGINT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    case_id        BIGINT NOT NULL REFERENCES cases(case_id) ON DELETE CASCADE,
    phrase         CITEXT NOT NULL,
    frequency      INTEGER DEFAULT 1,
    phrase_length  INTEGER,
    created_at     TIMESTAMP NOT NULL DEFAULT NOW()
);

CREATE INDEX IF NOT EXISTS idx_case_phrases_case_id ON case_phrases(case_id);
CREATE INDEX IF NOT EXISTS idx_case_phrases_phrase ON case_phrases(phrase);
CREATE INDEX IF NOT EXISTS idx_case_phrases_frequency ON case_phrases(frequency DESC);
```

**Columns**:
| Column | Type | Description |
|--------|------|-------------|
| phrase_id | BIGINT | Primary key |
| case_id | BIGINT | Case reference |
| phrase | CITEXT | N-gram phrase |
| frequency | INTEGER | Occurrences in case |
| phrase_length | INTEGER | Number of words (2, 3, 4) |

**Example Phrases**:

- "child custody" (bigram)
- "best interests of" (trigram)
- "abuse of discretion standard" (4-gram)

---

### 5. sentences

**Purpose**: Sentence-level indexing with embeddings

```sql
CREATE TABLE IF NOT EXISTS sentences (
    sentence_id    BIGINT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    case_id        BIGINT NOT NULL REFERENCES cases(case_id) ON DELETE CASCADE,
    chunk_id       UUID REFERENCES case_chunks(chunk_id) ON DELETE CASCADE,
    text           TEXT NOT NULL,
    position       INTEGER NOT NULL,
    word_count     INTEGER,
    embedding      VECTOR(1024),
    created_at     TIMESTAMP NOT NULL DEFAULT NOW()
);

CREATE INDEX IF NOT EXISTS idx_sentences_case_id ON sentences(case_id);
CREATE INDEX IF NOT EXISTS idx_sentences_chunk_id ON sentences(chunk_id);
CREATE INDEX IF NOT EXISTS idx_sentences_embedding ON sentences
    USING ivfflat (embedding vector_cosine_ops) WITH (lists = 100);
```

**Columns**:
| Column | Type | Description |
|--------|------|-------------|
| sentence_id | BIGINT | Primary key |
| case_id | BIGINT | Case reference |
| chunk_id | UUID | Chunk containing sentence |
| text | TEXT | Sentence content |
| position | INTEGER | Position in chunk |
| word_count | INTEGER | Word count |
| embedding | VECTOR(1024) | Sentence embedding |

---

### 6. anchors

**Purpose**: Named locations within documents

```sql
CREATE TABLE IF NOT EXISTS anchors (
    anchor_id      BIGINT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    case_id        BIGINT NOT NULL REFERENCES cases(case_id) ON DELETE CASCADE,
    chunk_id       UUID REFERENCES case_chunks(chunk_id) ON DELETE CASCADE,
    anchor_type    CITEXT NOT NULL,
    label          TEXT NOT NULL,
    position       INTEGER,
    created_at     TIMESTAMP NOT NULL DEFAULT NOW()
);

CREATE INDEX IF NOT EXISTS idx_anchors_case_id ON anchors(case_id);
CREATE INDEX IF NOT EXISTS idx_anchors_type ON anchors(anchor_type);
```

**Anchor Types**:

- section_header
- issue_marker
- citation_reference
- party_mention
- date_reference

---

### 7. statute_citations

**Purpose**: Link cases to statute references

```sql
CREATE TABLE IF NOT EXISTS statute_citations (
    citation_id    BIGINT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    case_id        BIGINT NOT NULL REFERENCES cases(case_id) ON DELETE CASCADE,
    statute_id     BIGINT NOT NULL REFERENCES statutes_dim(statute_id) ON DELETE CASCADE,
    chunk_id       UUID REFERENCES case_chunks(chunk_id) ON DELETE SET NULL,
    context        TEXT,
    created_at     TIMESTAMP NOT NULL DEFAULT NOW()
);

CREATE INDEX IF NOT EXISTS idx_statute_citations_case_id ON statute_citations(case_id);
CREATE INDEX IF NOT EXISTS idx_statute_citations_statute_id ON statute_citations(statute_id);
```

---

## Relationships & Foreign Keys

### Entity Relationship Diagram

```
                         ┌──────────────┐
                         │  case_types  │
                         │(dimension)   │
                         └──────┬───────┘
                                │
                         ┌──────▼───────┐         ┌──────────────┐
                         │ stage_types  │         │  courts_dim  │
                         │(dimension)   │         │(dimension)   │
                         └──────┬───────┘         └──────┬───────┘
                                │                        │
                         ┌──────▼────────────────────────▼───────┐
                         │              cases                     │
                         │         (central entity)               │
                         └──┬─────┬─────┬─────┬─────┬─────┬─────┘
                            │     │     │     │     │     │
          ┌─────────────────┘     │     │     │     │     └─────────────┐
          │                       │     │     │     │                   │
          ▼                       ▼     ▼     ▼     ▼                   ▼
    ┌──────────┐          ┌──────────────────────────────┐      ┌──────────┐
    │ parties  │          │      documents               │      │citations │
    └──────────┘          └──────────┬───────────────────┘      └──────────┘
          │                          │
    ┌─────▼──────┐          ┌────────▼────────┐
    │ attorneys  │          │  case_chunks    │
    └────────────┘          └────────┬────────┘
          │                          │
    ┌─────▼──────┐          ┌────────▼────────┬──────────────┬──────────┐
    │   judges   │          │ word_occurrence │  sentences   │ anchors  │
    └────────────┘          └────────┬────────┴──────────────┴──────────┘
          │                          │
    ┌─────▼────────────┐    ┌────────▼─────────┐
    │issues_decisions  │    │ word_dictionary  │
    └─────┬────────────┘    └──────────────────┘
          │
    ┌─────▼──────┐          ┌──────────────────┐
    │ arguments  │          │  case_phrases    │
    └────────────┘          └──────────────────┘
```

### Foreign Key Constraints

| Child Table       | Foreign Key      | Parent Table     | On Delete |
| ----------------- | ---------------- | ---------------- | --------- |
| cases             | case_type_id     | case_types       | SET NULL  |
| cases             | stage_type_id    | stage_types      | SET NULL  |
| cases             | court_id         | courts_dim       | SET NULL  |
| cases             | parent_case_id   | cases            | SET NULL  |
| parties           | case_id          | cases            | CASCADE   |
| attorneys         | case_id          | cases            | CASCADE   |
| judges            | case_id          | cases            | CASCADE   |
| issues_decisions  | case_id          | cases            | CASCADE   |
| arguments         | case_id          | cases            | CASCADE   |
| arguments         | issue_id         | issues_decisions | CASCADE   |
| citation_edges    | citing_case_id   | cases            | CASCADE   |
| citation_edges    | cited_case_id    | cases            | SET NULL  |
| documents         | case_id          | cases            | CASCADE   |
| documents         | stage_type_id    | stage_types      | RESTRICT  |
| documents         | document_type_id | document_types   | RESTRICT  |
| case_chunks       | case_id          | cases            | CASCADE   |
| word_occurrence   | case_id          | cases            | CASCADE   |
| word_occurrence   | chunk_id         | case_chunks      | CASCADE   |
| word_occurrence   | word_id          | word_dictionary  | CASCADE   |
| case_phrases      | case_id          | cases            | CASCADE   |
| sentences         | case_id          | cases            | CASCADE   |
| sentences         | chunk_id         | case_chunks      | CASCADE   |
| anchors           | case_id          | cases            | CASCADE   |
| statute_citations | case_id          | cases            | CASCADE   |
| statute_citations | statute_id       | statutes_dim     | CASCADE   |

**Delete Behaviors**:

- **CASCADE**: Child records deleted when parent deleted
- **SET NULL**: Foreign key set to NULL when parent deleted
- **RESTRICT**: Prevent deletion if child records exist

---

## Indexes

### Performance Indexes

```sql
-- Cases table
CREATE INDEX idx_cases_case_type_id ON cases(case_type_id);
CREATE INDEX idx_cases_stage_type_id ON cases(stage_type_id);
CREATE INDEX idx_cases_court_id ON cases(court_id);
CREATE INDEX idx_cases_published ON cases(published);
CREATE INDEX idx_cases_appeal_published_date ON cases(appeal_published_date);

-- Documents table
CREATE INDEX idx_documents_case_id ON documents(case_id);
CREATE INDEX idx_documents_status ON documents(processing_status);
CREATE INDEX idx_documents_stage_type ON documents(stage_type_id);

-- Entity tables
CREATE INDEX idx_parties_case_id ON parties(case_id);
CREATE INDEX idx_parties_name ON parties(name);
CREATE INDEX idx_attorneys_case_id ON attorneys(case_id);
CREATE INDEX idx_judges_case_id ON judges(case_id);
CREATE INDEX idx_issues_case_id ON issues_decisions(case_id);
CREATE INDEX idx_arguments_case_id ON arguments(case_id);
CREATE INDEX idx_citations_citing ON citation_edges(citing_case_id);

-- RAG tables
CREATE INDEX idx_case_chunks_case_id ON case_chunks(case_id);
CREATE INDEX idx_case_chunks_order ON case_chunks(case_id, chunk_order);
CREATE INDEX idx_word_occurrence_word_id ON word_occurrence(word_id);
CREATE INDEX idx_word_occurrence_case_id ON word_occurrence(case_id);
CREATE INDEX idx_case_phrases_phrase ON case_phrases(phrase);
CREATE INDEX idx_sentences_case_id ON sentences(case_id);
```

### Vector Similarity Indexes

```sql
-- IVFFlat indexes for vector similarity search
CREATE INDEX idx_cases_embedding ON cases
    USING ivfflat (full_embedding vector_cosine_ops)
    WITH (lists = 100);

CREATE INDEX idx_case_chunks_embedding ON case_chunks
    USING ivfflat (embedding vector_cosine_ops)
    WITH (lists = 100);

CREATE INDEX idx_sentences_embedding ON sentences
    USING ivfflat (embedding vector_cosine_ops)
    WITH (lists = 100);
```

**IVFFlat Parameters**:

- `lists = 100`: Number of clusters (good for 10K-1M rows)
- `vector_cosine_ops`: Cosine similarity operator class
- Recommended: lists ≈ sqrt(num_rows) for optimal performance

### Full-Text Search Indexes

```sql
-- GIN indexes for full-text search
CREATE INDEX idx_cases_title_gin ON cases
    USING gin(to_tsvector('english', title));

CREATE INDEX idx_cases_summary_gin ON cases
    USING gin(to_tsvector('english', summary));

CREATE INDEX idx_case_chunks_text_gin ON case_chunks
    USING gin(to_tsvector('english', text));
```

### Trigram Indexes

```sql
-- Trigram indexes for fuzzy matching
CREATE INDEX idx_parties_name_trgm ON parties
    USING gin(name gin_trgm_ops);

CREATE INDEX idx_attorneys_name_trgm ON attorneys
    USING gin(name gin_trgm_ops);

CREATE INDEX idx_judges_name_trgm ON judges
    USING gin(judge_name gin_trgm_ops);
```

---

## Triggers & Functions

### Updated At Trigger

```sql
-- Function to update updated_at timestamp
CREATE OR REPLACE FUNCTION set_updated_at()
RETURNS trigger AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Apply to tables with updated_at
CREATE TRIGGER trg_cases_updated
    BEFORE UPDATE ON cases
    FOR EACH ROW EXECUTE FUNCTION set_updated_at();

CREATE TRIGGER trg_documents_updated
    BEFORE UPDATE ON documents
    FOR EACH ROW EXECUTE FUNCTION set_updated_at();

CREATE TRIGGER trg_issues_decisions_updated
    BEFORE UPDATE ON issues_decisions
    FOR EACH ROW EXECUTE FUNCTION set_updated_at();

CREATE TRIGGER trg_arguments_updated
    BEFORE UPDATE ON arguments
    FOR EACH ROW EXECUTE FUNCTION set_updated_at();
```

### Potential Future Triggers

```sql
-- Trigger to update word frequency on insert
CREATE OR REPLACE FUNCTION update_word_frequency()
RETURNS trigger AS $$
BEGIN
  UPDATE word_dictionary
  SET frequency = frequency + 1
  WHERE word_id = NEW.word_id;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Trigger to validate date order
CREATE OR REPLACE FUNCTION validate_case_dates()
RETURNS trigger AS $$
BEGIN
  IF NEW.trial_end_date < NEW.trial_start_date THEN
    RAISE EXCEPTION 'Trial end date cannot be before start date';
  END IF;
  IF NEW.appeal_end_date < NEW.appeal_start_date THEN
    RAISE EXCEPTION 'Appeal end date cannot be before start date';
  END IF;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;
```

---

## Data Types & Constraints

### Custom Types & Enums

While PostgreSQL supports enums, this schema uses CITEXT for flexibility:

```sql
-- Court levels
'Appeals', 'Supreme'

-- Districts
'Division I', 'Division II', 'Division III', 'N/A'

-- Publication status
'Published', 'Unpublished', 'Partially Published'

-- Legal roles
'Appellant', 'Respondent', 'Petitioner', 'Third Party'

-- Personal roles (family law)
'Husband', 'Wife', 'Parent', 'Other', 'Estate'

-- Judge roles
'Authored by', 'Concurring', 'Dissenting', 'Joining'

-- Appeal outcomes
'affirmed', 'reversed', 'remanded', 'dismissed', 'partial', 'split'

-- Processing statuses
'pending', 'processing', 'completed', 'failed', 'indexed'
```

### Constraints Summary

| Constraint Type | Usage Count | Examples                 |
| --------------- | ----------- | ------------------------ |
| PRIMARY KEY     | 30+         | All tables have PK       |
| FOREIGN KEY     | 40+         | All relationships        |
| NOT NULL        | 100+        | Required fields          |
| UNIQUE          | 10+         | case_type, word, statute |
| DEFAULT         | 50+         | timestamps, booleans     |
| CHECK           | 0           | (potential future)       |

---

## Sample Queries

### 1. Search Cases by Title

```sql
SELECT case_id, title, court, appeal_published_date
FROM cases
WHERE to_tsvector('english', title) @@ to_tsquery('english', 'custody & support')
ORDER BY appeal_published_date DESC
LIMIT 20;
```

### 2. Find Similar Cases (Vector Search)

```sql
SELECT c.case_id, c.title, c.summary,
       1 - (c.full_embedding <=> :query_embedding) as similarity
FROM cases c
WHERE c.full_embedding IS NOT NULL
ORDER BY c.full_embedding <=> :query_embedding
LIMIT 10;
```

### 3. Word Occurrence Lookup

```sql
SELECT wo.case_id, c.title, cc.chunk_order, wo.position, cc.text
FROM word_occurrence wo
JOIN word_dictionary wd ON wo.word_id = wd.word_id
JOIN case_chunks cc ON wo.chunk_id = cc.chunk_id
JOIN cases c ON wo.case_id = c.case_id
WHERE wd.word = 'custody'
ORDER BY wo.case_id, cc.chunk_order, wo.position
LIMIT 50;
```

### 4. Find Cases by Issue Category

```sql
SELECT c.case_id, c.title, id.category, id.subcategory,
       id.appeal_outcome, id.winner_legal_role
FROM cases c
JOIN issues_decisions id ON c.case_id = id.case_id
WHERE id.category = 'Child Support'
  AND id.appeal_outcome = 'reversed'
ORDER BY c.appeal_published_date DESC;
```

### 5. Most Common Legal Phrases

```sql
SELECT phrase, SUM(frequency) as total_frequency, COUNT(DISTINCT case_id) as case_count
FROM case_phrases
GROUP BY phrase
HAVING SUM(frequency) >= 10
ORDER BY total_frequency DESC
LIMIT 50;
```

### 6. Context Window for Word

```sql
WITH target_word AS (
    SELECT wo.chunk_id, wo.position
    FROM word_occurrence wo
    JOIN word_dictionary wd ON wo.word_id = wd.word_id
    WHERE wd.word = 'custody' AND wo.chunk_id = :chunk_id
    LIMIT 1
),
context_words AS (
    SELECT wo.position, wd.word
    FROM word_occurrence wo
    JOIN word_dictionary wd ON wo.word_id = wd.word_id
    CROSS JOIN target_word tw
    WHERE wo.chunk_id = :chunk_id
      AND wo.position BETWEEN (tw.position - 10) AND (tw.position + 10)
    ORDER BY wo.position
)
SELECT string_agg(word, ' ' ORDER BY position) as context_sentence
FROM context_words;
```

### 7. Case Statistics

```sql
SELECT
    c.case_id,
    c.title,
    COUNT(DISTINCT p.party_id) as party_count,
    COUNT(DISTINCT a.attorney_id) as attorney_count,
    COUNT(DISTINCT j.judge_id) as judge_count,
    COUNT(DISTINCT id.issue_id) as issue_count,
    COUNT(DISTINCT cc.chunk_id) as chunk_count,
    COUNT(DISTINCT wo.word_id) as unique_word_count
FROM cases c
LEFT JOIN parties p ON c.case_id = p.case_id
LEFT JOIN attorneys a ON c.case_id = a.case_id
LEFT JOIN judges j ON c.case_id = j.case_id
LEFT JOIN issues_decisions id ON c.case_id = id.case_id
LEFT JOIN case_chunks cc ON c.case_id = cc.case_id
LEFT JOIN word_occurrence wo ON c.case_id = wo.case_id
WHERE c.case_id = :case_id
GROUP BY c.case_id, c.title;
```

### 8. Fuzzy Name Search

```sql
SELECT name, legal_role, party_type
FROM parties
WHERE similarity(name, 'John Smith') > 0.3
ORDER BY similarity(name, 'John Smith') DESC
LIMIT 10;
```

### 9. Citation Network

```sql
-- Cases cited by a specific case
SELECT c.case_id, c.title, ce.citation, ce.relevance
FROM citation_edges ce
JOIN cases c ON ce.cited_case_id = c.case_id
WHERE ce.citing_case_id = :case_id;

-- Cases that cite a specific case
SELECT c.case_id, c.title, ce.citation
FROM citation_edges ce
JOIN cases c ON ce.citing_case_id = c.case_id
WHERE ce.cited_case_id = :case_id;
```

### 10. Hybrid Search (Semantic + Lexical)

```sql
WITH semantic_results AS (
    SELECT case_id, 1 - (full_embedding <=> :query_embedding) as score
    FROM cases
    WHERE full_embedding IS NOT NULL
    ORDER BY score DESC
    LIMIT 20
),
lexical_results AS (
    SELECT case_id, ts_rank(to_tsvector('english', title || ' ' || summary),
                            to_tsquery('english', :query_text)) as score
    FROM cases
    WHERE to_tsvector('english', title || ' ' || summary) @@ to_tsquery('english', :query_text)
    ORDER BY score DESC
    LIMIT 20
)
SELECT c.case_id, c.title, c.summary,
       COALESCE(sr.score, 0) + COALESCE(lr.score, 0) as combined_score
FROM cases c
LEFT JOIN semantic_results sr ON c.case_id = sr.case_id
LEFT JOIN lexical_results lr ON c.case_id = lr.case_id
WHERE sr.case_id IS NOT NULL OR lr.case_id IS NOT NULL
ORDER BY combined_score DESC;
```

---

## Database Maintenance

### Vacuum & Analyze

```sql
-- Full vacuum (reclaim space)
VACUUM FULL cases;
VACUUM FULL case_chunks;

-- Analyze for query planner
ANALYZE cases;
ANALYZE case_chunks;
ANALYZE word_occurrence;

-- Auto-vacuum settings (in postgresql.conf)
autovacuum = on
autovacuum_max_workers = 3
autovacuum_naptime = 1min
```

### Index Maintenance

```sql
-- Rebuild vector indexes
REINDEX INDEX idx_cases_embedding;
REINDEX INDEX idx_case_chunks_embedding;

-- Check index bloat
SELECT schemaname, tablename, indexname,
       pg_size_pretty(pg_relation_size(indexrelid)) as index_size
FROM pg_stat_user_indexes
ORDER BY pg_relation_size(indexrelid) DESC;
```

### Statistics

```sql
-- Row counts
SELECT schemaname, tablename, n_live_tup as row_count
FROM pg_stat_user_tables
ORDER BY n_live_tup DESC;

-- Database size
SELECT pg_size_pretty(pg_database_size('cases_llama3.3'));

-- Table sizes
SELECT tablename,
       pg_size_pretty(pg_total_relation_size(schemaname||'.'||tablename)) as size
FROM pg_tables
WHERE schemaname = 'public'
ORDER BY pg_total_relation_size(schemaname||'.'||tablename) DESC;
```

---

## Performance Tuning

### Connection Settings

```sql
-- postgresql.conf
max_connections = 200
shared_buffers = 4GB
effective_cache_size = 12GB
maintenance_work_mem = 1GB
work_mem = 64MB
```

### Query Optimization Tips

1. **Use Prepared Statements**: Reduce parsing overhead
2. **Index Coverage**: Ensure WHERE/JOIN columns are indexed
3. **Vector Index Tuning**: Adjust IVFFlat lists based on row count
4. **Limit Results**: Always use LIMIT for large result sets
5. **Explain Analyze**: Check query plans regularly

```sql
EXPLAIN ANALYZE
SELECT case_id, title FROM cases WHERE case_type_id = 1;
```

### Monitoring Queries

```sql
-- Slow queries
SELECT query, calls, total_time, mean_time
FROM pg_stat_statements
ORDER BY mean_time DESC
LIMIT 20;

-- Index usage
SELECT schemaname, tablename, indexname, idx_scan
FROM pg_stat_user_indexes
WHERE idx_scan = 0 AND indexrelid IS NOT NULL;
```

---

## Backup & Restore

### Backup Commands

```bash
# Full database backup
pg_dump -h localhost -p 5433 -U legal_user -d cases_llama3.3 -F c -f backup.dump

# Schema only
pg_dump -h localhost -p 5433 -U legal_user -d cases_llama3.3 -s -f schema.sql

# Data only
pg_dump -h localhost -p 5433 -U legal_user -d cases_llama3.3 -a -f data.sql

# Specific table
pg_dump -h localhost -p 5433 -U legal_user -d cases_llama3.3 -t cases -f cases.sql
```

### Restore Commands

```bash
# Restore from custom format
pg_restore -h localhost -p 5433 -U legal_user -d cases_llama3.3 backup.dump

# Restore from SQL
psql -h localhost -p 5433 -U legal_user -d cases_llama3.3 -f backup.sql
```

---

## Security Considerations

### User Privileges

```sql
-- Create read-only user
CREATE USER legal_readonly WITH PASSWORD 'readonly_password';
GRANT CONNECT ON DATABASE "cases_llama3.3" TO legal_readonly;
GRANT USAGE ON SCHEMA public TO legal_readonly;
GRANT SELECT ON ALL TABLES IN SCHEMA public TO legal_readonly;

-- Create application user
CREATE USER legal_app WITH PASSWORD 'app_password';
GRANT CONNECT ON DATABASE "cases_llama3.3" TO legal_app;
GRANT USAGE ON SCHEMA public TO legal_app;
GRANT SELECT, INSERT, UPDATE, DELETE ON ALL TABLES IN SCHEMA public TO legal_app;
GRANT USAGE, SELECT ON ALL SEQUENCES IN SCHEMA public TO legal_app;
```

### SSL Configuration

```sql
-- postgresql.conf
ssl = on
ssl_cert_file = '/path/to/server.crt'
ssl_key_file = '/path/to/server.key'
```

### Row-Level Security (Future)

```sql
-- Example: Restrict access by case ownership
ALTER TABLE cases ENABLE ROW LEVEL SECURITY;

CREATE POLICY case_access_policy ON cases
    FOR SELECT
    USING (case_id IN (SELECT case_id FROM user_case_access WHERE user_id = current_user));
```

---

## Appendix

### Table Size Reference

| Table Type       | Expected Rows | Typical Size |
| ---------------- | ------------- | ------------ |
| cases            | 10K-100K      | 500MB-5GB    |
| case_chunks      | 100K-1M       | 2GB-20GB     |
| word_occurrence  | 10M-100M      | 5GB-50GB     |
| word_dictionary  | 100K-500K     | 50MB-200MB   |
| case_phrases     | 1M-10M        | 500MB-5GB    |
| parties          | 20K-200K      | 10MB-100MB   |
| attorneys        | 10K-100K      | 10MB-100MB   |
| issues_decisions | 50K-500K      | 100MB-1GB    |

### Vector Dimension Guidelines

- **1024 dimensions**: Standard for modern embedding models
- **Storage per vector**: ~4KB (1024 × 4 bytes float32)
- **Index overhead**: ~2-3x storage size for IVFFlat
- **Query performance**: Sub-second for 1M vectors with proper indexing

### Washington State RCW References

| RCW           | Topic                     |
| ------------- | ------------------------- |
| RCW 26.09.090 | Spousal maintenance       |
| RCW 26.19.071 | Child support calculation |
| RCW 26.09.187 | Parenting plans           |
| RCW 26.09.080 | Property division         |
| RCW 26.09.140 | Attorney fees             |
| RCW 26.09.160 | Contempt proceedings      |
| RCW 26.09.170 | Modification of orders    |

---

**Document Version**: 1.0  
**Last Updated**: 2025-01-20  
**PostgreSQL Version**: 16+  
**Database**: cases_llama3.3
